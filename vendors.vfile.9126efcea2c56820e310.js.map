{"version":3,"sources":["webpack:///./node_modules/vfile/index.js","webpack:///./node_modules/vfile/lib/index.js","webpack:///./node_modules/vfile/lib/core.js","webpack:///./node_modules/vfile/lib/minpath.browser.js","webpack:///./node_modules/vfile/lib/minproc.browser.js","webpack:///./node_modules/vfile/node_modules/is-buffer/index.js"],"names":["module","exports","VMessage","VFile","prototype","message","reason","position","origin","this","path","name","file","fatal","messages","push","info","apply","arguments","fail","p","proc","buffer","own","hasOwnProperty","order","options","prop","index","contents","data","history","cwd","length","call","indexOf","assertPart","part","sep","Error","assertNonEmpty","assertPath","toString","encoding","Object","defineProperty","get","set","dirname","undefined","join","basename","extname","charCodeAt","stem","normalize","absolute","value","allowAboveRoot","code","lastSlashIndex","result","lastSegmentLength","lastSlash","dots","lastIndexOf","slice","normalizeString","TypeError","JSON","stringify","ext","firstNonSlashEnd","seenNonSlash","extIndex","start","end","unmatchedSlash","startDot","startPart","preDotState","joined","obj","constructor","isBuffer"],"mappings":"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","file":"vendors.vfile.9126efcea2c56820e310.js","sourcesContent":["'use strict'\n\nmodule.exports = require('./lib')\n","'use strict'\n\nvar VMessage = require('vfile-message')\nvar VFile = require('./core.js')\n\nmodule.exports = VFile\n\nVFile.prototype.message = message\nVFile.prototype.info = info\nVFile.prototype.fail = fail\n\n// Create a message with `reason` at `position`.\n// When an error is passed in as `reason`, copies the stack.\nfunction message(reason, position, origin) {\n  var message = new VMessage(reason, position, origin)\n\n  if (this.path) {\n    message.name = this.path + ':' + message.name\n    message.file = this.path\n  }\n\n  message.fatal = false\n\n  this.messages.push(message)\n\n  return message\n}\n\n// Fail: creates a vmessage, associates it with the file, and throws it.\nfunction fail() {\n  var message = this.message.apply(this, arguments)\n\n  message.fatal = true\n\n  throw message\n}\n\n// Info: creates a vmessage, associates it with the file, and marks the fatality\n// as null.\nfunction info() {\n  var message = this.message.apply(this, arguments)\n\n  message.fatal = null\n\n  return message\n}\n","'use strict'\n\nvar p = require('./minpath')\nvar proc = require('./minproc')\nvar buffer = require('is-buffer')\n\nmodule.exports = VFile\n\nvar own = {}.hasOwnProperty\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nvar order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nVFile.prototype.toString = toString\n\n// Access full path (`~/index.min.js`).\nObject.defineProperty(VFile.prototype, 'path', {get: getPath, set: setPath})\n\n// Access parent path (`~`).\nObject.defineProperty(VFile.prototype, 'dirname', {\n  get: getDirname,\n  set: setDirname\n})\n\n// Access basename (`index.min.js`).\nObject.defineProperty(VFile.prototype, 'basename', {\n  get: getBasename,\n  set: setBasename\n})\n\n// Access extname (`.js`).\nObject.defineProperty(VFile.prototype, 'extname', {\n  get: getExtname,\n  set: setExtname\n})\n\n// Access stem (`index.min`).\nObject.defineProperty(VFile.prototype, 'stem', {get: getStem, set: setStem})\n\n// Construct a new file.\nfunction VFile(options) {\n  var prop\n  var index\n\n  if (!options) {\n    options = {}\n  } else if (typeof options === 'string' || buffer(options)) {\n    options = {contents: options}\n  } else if ('message' in options && 'messages' in options) {\n    return options\n  }\n\n  if (!(this instanceof VFile)) {\n    return new VFile(options)\n  }\n\n  this.data = {}\n  this.messages = []\n  this.history = []\n  this.cwd = proc.cwd()\n\n  // Set path related properties in the correct order.\n  index = -1\n\n  while (++index < order.length) {\n    prop = order[index]\n\n    if (own.call(options, prop)) {\n      this[prop] = options[prop]\n    }\n  }\n\n  // Set non-path related properties.\n  for (prop in options) {\n    if (order.indexOf(prop) < 0) {\n      this[prop] = options[prop]\n    }\n  }\n}\n\nfunction getPath() {\n  return this.history[this.history.length - 1]\n}\n\nfunction setPath(path) {\n  assertNonEmpty(path, 'path')\n\n  if (this.path !== path) {\n    this.history.push(path)\n  }\n}\n\nfunction getDirname() {\n  return typeof this.path === 'string' ? p.dirname(this.path) : undefined\n}\n\nfunction setDirname(dirname) {\n  assertPath(this.path, 'dirname')\n  this.path = p.join(dirname || '', this.basename)\n}\n\nfunction getBasename() {\n  return typeof this.path === 'string' ? p.basename(this.path) : undefined\n}\n\nfunction setBasename(basename) {\n  assertNonEmpty(basename, 'basename')\n  assertPart(basename, 'basename')\n  this.path = p.join(this.dirname || '', basename)\n}\n\nfunction getExtname() {\n  return typeof this.path === 'string' ? p.extname(this.path) : undefined\n}\n\nfunction setExtname(extname) {\n  assertPart(extname, 'extname')\n  assertPath(this.path, 'extname')\n\n  if (extname) {\n    if (extname.charCodeAt(0) !== 46 /* `.` */) {\n      throw new Error('`extname` must start with `.`')\n    }\n\n    if (extname.indexOf('.', 1) > -1) {\n      throw new Error('`extname` cannot contain multiple dots')\n    }\n  }\n\n  this.path = p.join(this.dirname, this.stem + (extname || ''))\n}\n\nfunction getStem() {\n  return typeof this.path === 'string'\n    ? p.basename(this.path, this.extname)\n    : undefined\n}\n\nfunction setStem(stem) {\n  assertNonEmpty(stem, 'stem')\n  assertPart(stem, 'stem')\n  this.path = p.join(this.dirname || '', stem + (this.extname || ''))\n}\n\n// Get the value of the file.\nfunction toString(encoding) {\n  return (this.contents || '').toString(encoding)\n}\n\n// Assert that `part` is not a path (i.e., does not contain `p.sep`).\nfunction assertPart(part, name) {\n  if (part && part.indexOf(p.sep) > -1) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + p.sep + '`'\n    )\n  }\n}\n\n// Assert that `part` is not empty.\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n// Assert `path` exists.\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n","'use strict'\n\n// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexports.basename = basename\nexports.dirname = dirname\nexports.extname = extname\nexports.join = join\nexports.sep = '/'\n\nfunction basename(path, ext) {\n  var start = 0\n  var end = -1\n  var index\n  var firstNonSlashEnd\n  var seenNonSlash\n  var extIndex\n\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  index = path.length\n\n  if (ext === undefined || !ext.length || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  firstNonSlashEnd = -1\n  extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\nfunction dirname(path) {\n  var end\n  var unmatchedSlash\n  var index\n\n  assertPath(path)\n\n  if (!path.length) {\n    return '.'\n  }\n\n  end = -1\n  index = path.length\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\nfunction extname(path) {\n  var startDot = -1\n  var startPart = 0\n  var end = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  var preDotState = 0\n  var unmatchedSlash\n  var code\n  var index\n\n  assertPath(path)\n\n  index = path.length\n\n  while (index--) {\n    code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\nfunction join() {\n  var index = -1\n  var joined\n\n  while (++index < arguments.length) {\n    assertPath(arguments[index])\n\n    if (arguments[index]) {\n      joined =\n        joined === undefined\n          ? arguments[index]\n          : joined + '/' + arguments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  var absolute\n  var value\n\n  assertPath(path)\n\n  absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  value = normalizeString(path, !absolute)\n\n  if (!value.length && !absolute) {\n    value = '.'\n  }\n\n  if (value.length && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n// Resolve `.` and `..` elements in a path with directory names.\nfunction normalizeString(path, allowAboveRoot) {\n  var result = ''\n  var lastSegmentLength = 0\n  var lastSlash = -1\n  var dots = 0\n  var index = -1\n  var code\n  var lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            /* istanbul ignore else - No clue how to cover it. */\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n","'use strict'\n\n// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don’t think one tiny line of code can be copyrighted. 😅\nexports.cwd = cwd\n\nfunction cwd() {\n  return '/'\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n"],"sourceRoot":""}